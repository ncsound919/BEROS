"""
Test suite for Session API endpoints
Generated by AutoCoder Marathon Build

Template variables:
  - endpoint_prefix: str (default "/api/v1/session")
"""

import pytest
import json
from fastapi import status


class TestSessionEndpoint:
    """Test session CRUD operations via API endpoints."""

    def test_get_session_existing(self, test_client, redis_client, sample_session):
        """Test retrieving an existing session."""
        # Pre-populate session in Redis
        session_id = sample_session["session_id"]
        redis_client.setex(
            f"session:{session_id}",
            1800,
            json.dumps(sample_session)
        )

        # GET request
        response = test_client.get(
            "{{ endpoint_prefix }}/get",
            params={"session_id": session_id}
        )

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data["session_id"] == session_id
        assert data["protocol_id"] == sample_session["protocol_id"]
        assert "fields" in data

    def test_get_session_nonexistent(self, test_client):
        """Test retrieving a non-existent session returns minimal object."""
        response = test_client.get(
            "{{ endpoint_prefix }}/get",
            params={"session_id": "nonexistent_session"}
        )

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data["session_id"] == "nonexistent_session"
        assert data["protocol_id"] is None
        assert data["fields"] == {}
        assert data["transcript"] == []

    def test_save_session(self, test_client, redis_client):
        """Test saving a new session."""
        new_session = {
            "session_id": "new_session_001",
            "protocol_id": "billing_invoice_v1",
            "node": "start",
            "fields": {"invoice_id": "INV999"},
            "transcript": [],
            "route_key": "billing:invoice"
        }

        response = test_client.post(
            "{{ endpoint_prefix }}/save",
            json=new_session
        )

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data["ok"] is True
        assert data["session_id"] == "new_session_001"

        # Verify it was saved to Redis
        saved = redis_client.get("session:new_session_001")
        assert saved is not None
        saved_data = json.loads(saved)
        assert saved_data["session_id"] == "new_session_001"
        assert "updated_ts" in saved_data

    def test_save_session_with_custom_ttl(self, test_client, redis_client):
        """Test saving session with custom TTL."""
        new_session = {
            "session_id": "ttl_test_session",
            "protocol_id": "test_proto",
            "fields": {},
            "transcript": []
        }

        response = test_client.post(
            "{{ endpoint_prefix }}/save?ttl=600",
            json=new_session
        )

        assert response.status_code == status.HTTP_200_OK

        # Verify TTL is set (should be ~600 seconds, allow some variance)
        ttl = redis_client.ttl("session:ttl_test_session")
        assert 590 <= ttl <= 610

    def test_get_logs(self, test_client, redis_client):
        """Test retrieving session logs."""
        session_id = "log_test_session"

        # Pre-populate some logs
        log_entries = [
            {"event": "claimed", "agent_id": "agent-001", "ts": 1609459200},
            {"event": "disposition", "code": "resolved", "ts": 1609459300}
        ]

        for entry in log_entries:
            redis_client.rpush(f"log:{session_id}", json.dumps(entry))

        response = test_client.get(
            "{{ endpoint_prefix }}/logs",
            params={"session_id": session_id}
        )

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert isinstance(data, list)
        assert len(data) == 2
        assert data[0]["event"] == "claimed"
        assert data[1]["event"] == "disposition"

    def test_get_logs_empty(self, test_client):
        """Test retrieving logs for session with no logs."""
        response = test_client.get(
            "{{ endpoint_prefix }}/logs",
            params={"session_id": "no_logs_session"}
        )

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data == []

    def test_append_log(self, test_client, redis_client):
        """Test appending a log entry."""
        session_id = "append_log_session"

        log_entry = {
            "event": "test_event",
            "data": {"key": "value"}
        }

        response = test_client.post(
            f"{{ endpoint_prefix }}/log?session_id={session_id}",
            json=log_entry
        )

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data["ok"] is True
        assert data["session_id"] == session_id
        assert data["log_event"] == "test_event"

        # Verify log was saved
        logs = redis_client.lrange(f"log:{session_id}", 0, -1)
        assert len(logs) == 1
        saved_log = json.loads(logs[0])
        assert saved_log["event"] == "test_event"
        assert "ts" in saved_log

    def test_append_log_auto_timestamp(self, test_client, redis_client):
        """Test that log entries receive automatic timestamp if not provided."""
        import time

        session_id = "auto_ts_session"
        before = time.time()

        log_entry = {
            "event": "auto_timestamp_event"
        }

        response = test_client.post(
            f"{{ endpoint_prefix }}/log?session_id={session_id}",
            json=log_entry
        )

        after = time.time()

        assert response.status_code == status.HTTP_200_OK

        # Retrieve and check timestamp
        logs = redis_client.lrange(f"log:{session_id}", 0, -1)
        saved_log = json.loads(logs[0])
        assert "ts" in saved_log
        assert before <= saved_log["ts"] <= after

    def test_delete_session(self, test_client, redis_client):
        """Test deleting a session and its logs."""
        session_id = "delete_test_session"

        # Create session and logs
        redis_client.setex(f"session:{session_id}", 1800, json.dumps({"session_id": session_id}))
        redis_client.rpush(f"log:{session_id}", json.dumps({"event": "test"}))

        # Verify they exist
        assert redis_client.exists(f"session:{session_id}") == 1
        assert redis_client.exists(f"log:{session_id}") == 1

        # Delete
        response = test_client.post(
            "{{ endpoint_prefix }}/delete",
            params={"session_id": session_id}
        )

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data["ok"] is True

        # Verify deletion
        assert redis_client.exists(f"session:{session_id}") == 0
        assert redis_client.exists(f"log:{session_id}") == 0

    def test_session_model_validation(self, test_client):
        """Test that invalid session data is rejected."""
        invalid_session = {
            "session_id": "valid_id"
            # Missing required fields should still be accepted with defaults
        }

        response = test_client.post(
            "{{ endpoint_prefix }}/save",
            json=invalid_session
        )

        # Should succeed with defaults
        assert response.status_code == status.HTTP_200_OK

    def test_get_logs_with_range(self, test_client, redis_client):
        """Test retrieving a range of logs."""
        session_id = "range_log_session"

        # Add 10 log entries
        for i in range(10):
            redis_client.rpush(
                f"log:{session_id}",
                json.dumps({"event": f"event_{i}", "index": i})
            )

        # Get logs 2-4 (inclusive)
        response = test_client.get(
            "{{ endpoint_prefix }}/logs",
            params={"session_id": session_id, "start": 2, "end": 4}
        )

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert len(data) == 3
        assert data[0]["index"] == 2
        assert data[1]["index"] == 3
        assert data[2]["index"] == 4
