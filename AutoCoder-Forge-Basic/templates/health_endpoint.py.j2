"""
Health check endpoint for AetherDesk API
Generated by AutoCoder - Marathon Build

Template variables:
  - include_redis_check: bool (default True)
  - include_version: str (default "0.2")
  - check_dependencies: bool (default True)
"""

from typing import Dict, Any
import time
{% if include_redis_check %}
import redis
{% endif %}

from fastapi import APIRouter, Request, status
from pydantic import BaseModel, Field

router = APIRouter(prefix="/health", tags=["health"])


class HealthResponse(BaseModel):
    status: str = Field(..., description="Overall health status: healthy, degraded, or unhealthy")
    timestamp: float = Field(..., description="Unix timestamp of health check")
    version: str = Field(..., description="API version")
    checks: Dict[str, Any] = Field(default_factory=dict, description="Individual component checks")


class ComponentCheck(BaseModel):
    status: str = Field(..., description="Component status: up, down, or unknown")
    latency_ms: float = Field(None, description="Response time in milliseconds")
    message: str = Field(None, description="Additional status information")


@router.get("/", response_model=HealthResponse, status_code=status.HTTP_200_OK)
async def health_check(request: Request) -> HealthResponse:
    """
    Comprehensive health check endpoint.

    Returns:
        - 200 OK if all checks pass (status: healthy)
        - 200 OK if some checks fail but system is usable (status: degraded)
        - 503 Service Unavailable if critical checks fail (status: unhealthy)
    """
    start_time = time.time()
    checks = {}
    overall_status = "healthy"

    {% if include_redis_check %}
    # Check Redis connectivity
    redis_check = await _check_redis(request)
    checks["redis"] = redis_check
    if redis_check["status"] == "down":
        overall_status = "unhealthy"
    {% endif %}

    {% if check_dependencies %}
    # Check Python dependencies availability
    checks["dependencies"] = _check_dependencies()
    {% endif %}

    # Basic API check
    checks["api"] = {
        "status": "up",
        "message": "API is operational"
    }

    # Calculate total check time
    total_latency = (time.time() - start_time) * 1000

    response = HealthResponse(
        status=overall_status,
        timestamp=time.time(),
        version="{{ include_version }}",
        checks=checks
    )

    return response


@router.get("/ready", status_code=status.HTTP_200_OK)
async def readiness_check(request: Request) -> Dict[str, Any]:
    """
    Kubernetes-style readiness probe.
    Returns 200 if service is ready to accept traffic.
    """
    {% if include_redis_check %}
    redis_check = await _check_redis(request)
    if redis_check["status"] == "down":
        return {
            "ready": False,
            "reason": "Redis connection failed"
        }
    {% endif %}

    return {
        "ready": True,
        "timestamp": time.time()
    }


@router.get("/live", status_code=status.HTTP_200_OK)
async def liveness_check() -> Dict[str, Any]:
    """
    Kubernetes-style liveness probe.
    Returns 200 if service process is alive.
    """
    return {
        "alive": True,
        "timestamp": time.time()
    }


{% if include_redis_check %}
async def _check_redis(request: Request) -> Dict[str, Any]:
    """Check Redis connectivity and response time."""
    start = time.time()
    try:
        r = request.app.state.redis
        # Simple ping test
        result = r.ping()
        latency = (time.time() - start) * 1000

        if result:
            return {
                "status": "up",
                "latency_ms": round(latency, 2),
                "message": "Redis connection successful"
            }
        else:
            return {
                "status": "down",
                "latency_ms": round(latency, 2),
                "message": "Redis ping failed"
            }
    except redis.ConnectionError as e:
        return {
            "status": "down",
            "latency_ms": None,
            "message": f"Redis connection error: {str(e)}"
        }
    except Exception as e:
        return {
            "status": "down",
            "latency_ms": None,
            "message": f"Redis check failed: {str(e)}"
        }
{% endif %}


{% if check_dependencies %}
def _check_dependencies() -> Dict[str, Any]:
    """Check that critical Python dependencies are available."""
    required = ["fastapi", "redis", "twilio", "pydantic", "jinja2"]
    missing = []

    for dep in required:
        try:
            __import__(dep)
        except ImportError:
            missing.append(dep)

    if missing:
        return {
            "status": "degraded",
            "message": f"Missing dependencies: {', '.join(missing)}"
        }
    else:
        return {
            "status": "up",
            "message": "All dependencies available"
        }
{% endif %}
