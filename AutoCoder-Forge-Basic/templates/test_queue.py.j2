"""
Test suite for QueueManager operations
Generated by AutoCoder Marathon Build

Template variables:
  - test_redis: bool (default True)
"""

import pytest
import json
import time
from apps.api.services.queue import QueueManager


class TestQueueManager:
    """Test QueueManager Redis queue operations."""

    def test_enqueue_item(self, redis_client):
        """Test enqueueing an item to a queue."""
        qm = QueueManager(redis_client)

        item = {
            "session_id": "s001",
            "protocol_id": "billing_invoice_v1",
            "preview": "Invoice INV-123",
            "queue": "general"
        }

        qm.enqueue("general", item)

        # Verify item was added
        items = qm.peek("general", n=10)
        assert len(items) == 1
        assert items[0]["session_id"] == "s001"
        assert items[0]["protocol_id"] == "billing_invoice_v1"
        assert "created_ts" in items[0]

    def test_peek_queue(self, redis_client):
        """Test peeking at queue items without removing them."""
        qm = QueueManager(redis_client)

        # Add multiple items
        for i in range(5):
            qm.enqueue("general", {
                "session_id": f"s{i:03d}",
                "protocol_id": "test_proto",
                "preview": f"Test {i}",
                "queue": "general"
            })

        # Peek at 3 items
        items = qm.peek("general", n=3)
        assert len(items) == 3

        # Verify items are still in queue
        all_items = qm.peek("general", n=10)
        assert len(all_items) == 5

    def test_claim_item(self, redis_client):
        """Test claiming an item from the queue."""
        qm = QueueManager(redis_client)

        # Enqueue an item
        qm.enqueue("general", {
            "session_id": "s001",
            "protocol_id": "test_proto",
            "preview": "Test item",
            "queue": "general"
        })

        # Claim the item
        claimed = qm.claim("general", "agent-001")

        assert claimed is not None
        assert claimed["session_id"] == "s001"
        assert claimed["claimed_by"] == "agent-001"
        assert "claimed_ts" in claimed

        # Verify queue is now empty
        items = qm.peek("general", n=10)
        assert len(items) == 0

    def test_claim_empty_queue(self, redis_client):
        """Test claiming from an empty queue returns None."""
        qm = QueueManager(redis_client)

        claimed = qm.claim("empty_queue", "agent-001")
        assert claimed is None

    def test_session_set_and_get(self, redis_client):
        """Test setting and getting session data."""
        qm = QueueManager(redis_client)

        session_data = {
            "session_id": "s001",
            "protocol_id": "billing_invoice_v1",
            "fields": {"invoice_id": "INV123", "zip": "12345"},
            "transcript": []
        }

        # Set session
        qm.session_set("s001", session_data, ttl=3600)

        # Get session
        retrieved = qm.session_get("s001")

        assert retrieved is not None
        assert retrieved["session_id"] == "s001"
        assert retrieved["protocol_id"] == "billing_invoice_v1"
        assert retrieved["fields"]["invoice_id"] == "INV123"

    def test_session_get_nonexistent(self, redis_client):
        """Test getting a non-existent session returns None."""
        qm = QueueManager(redis_client)

        retrieved = qm.session_get("nonexistent")
        assert retrieved is None

    def test_fifo_ordering(self, redis_client):
        """Test that queue maintains FIFO ordering."""
        qm = QueueManager(redis_client)

        # Enqueue items in order
        for i in range(3):
            qm.enqueue("general", {
                "session_id": f"s{i:03d}",
                "protocol_id": "test_proto",
                "preview": f"Test {i}",
                "queue": "general"
            })
            time.sleep(0.01)  # Ensure different timestamps

        # Claim items and verify order (FIFO = first in, first out)
        first = qm.claim("general", "agent-001")
        second = qm.claim("general", "agent-002")
        third = qm.claim("general", "agent-003")

        # First enqueued should be first claimed (oldest)
        assert first["session_id"] == "s000"
        assert second["session_id"] == "s001"
        assert third["session_id"] == "s002"

    def test_multiple_queues(self, redis_client):
        """Test that different queues are independent."""
        qm = QueueManager(redis_client)

        # Add items to different queues
        qm.enqueue("rx", {
            "session_id": "rx001",
            "protocol_id": "pharmacy_refill_v1",
            "preview": "Rx refill",
            "queue": "rx"
        })

        qm.enqueue("billing", {
            "session_id": "bill001",
            "protocol_id": "billing_invoice_v1",
            "preview": "Invoice query",
            "queue": "billing"
        })

        # Verify each queue has only its own items
        rx_items = qm.peek("rx", n=10)
        billing_items = qm.peek("billing", n=10)

        assert len(rx_items) == 1
        assert len(billing_items) == 1
        assert rx_items[0]["session_id"] == "rx001"
        assert billing_items[0]["session_id"] == "bill001"

    def test_queue_item_has_timestamp(self, redis_client):
        """Test that enqueued items receive a timestamp."""
        qm = QueueManager(redis_client)

        before = time.time()

        qm.enqueue("general", {
            "session_id": "s001",
            "protocol_id": "test_proto",
            "preview": "Test",
            "queue": "general"
        })

        after = time.time()

        items = qm.peek("general", n=1)
        assert len(items) == 1
        assert "created_ts" in items[0]

        # Verify timestamp is reasonable
        ts = items[0]["created_ts"]
        assert before <= ts <= after

    {% if test_redis %}
    def test_redis_connection_required(self):
        """Test that QueueManager requires a Redis client."""
        with pytest.raises((AttributeError, TypeError)):
            qm = QueueManager(None)
            qm.peek("general", n=1)
    {% endif %}
